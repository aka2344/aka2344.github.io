<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>aka2344.github.io</title>
   
   <link>http://localhost:4000</link>
   <description>나의 코딩 이야기</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[종만북]28.그래프의 깊이 우선 탐색-고대어 사전</title>
	  <link>//DICTIONARY</link>
	  <author></author>
	  <pubDate>2021-02-19T04:25:52+09:00</pubDate>
	  <guid>//DICTIONARY</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/DICTIONARY</p>

<p>아마추어 고고학자인 일리노이 존스는 시카고 근교에서 고대 문명의 흔적을 찾아냈습니다. 그 흔적 중에는 이 언어의 사전도 포함되어 있었는데, 이 사전에 포함된 단어들은 모두 영어의 소문자 알파벳으로 구성되어 있었지만 사전에 포함된 단어의 순서들이 영어와 서로 달랐습니다. 발굴팀은 단어들이 사전 순이 아닌 다른 순서대로 정렬되어 있는지, 아니면 알파벳들의 순서가 영어와 서로 다른 것인지를 알고 싶어합니다.</p>

<p>일리노이 존스는 이 언어에서는 알파벳들의 순서가 영어와 서로 다를 뿐, 사전의 단어들은 사전 순서대로 배치되어 있다는 가설을 세웠습니다. 이 가설이 사실이라고 가정하고, 단어의 목록으로부터 알파벳의 순서를 찾아내려고 합니다.</p>

<p>예를 들어 다섯 개의 단어 gg, kia, lotte, lg, hanhwa 가 사전에 순서대로 적혀 있다고 합시다. gg가 kia보다 앞에 오려면 이 언어에서는 g가 k보다 앞에 와야 합니다. 같은 원리로 k는 l앞에, l은 h앞에 와야 한다는 것을 알 수 있지요. lotte 가 lg 보다 앞에 오려면 o가 g 보다 앞에 와야 한다는 것도 알 수 있습니다. 이들을 종합하면 다섯 개의 알파벳 o, g, k, l, h 의 상대적 순서를 알게 됩니다.</p>

<p>사전에 포함된 단어들의 목록이 순서대로 주어질 때 이 언어에서 알파벳의 순서를 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 사전에 포함된 단어의 수 N (1 &lt;= N &lt;= 1000) 이 주어집니다. 그 후 N 줄에 하나씩 사전에 포함된 단어가 순서대로 주어집니다. 각 단어는 알파벳 소문자로 구성되어 있으며, 길이는 1 이상 20 이하입니다. 중복으로 출현하는 단어는 없습니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄을 출력합니다. 만약 알파벳들의 순서에 모순이 있다면 “INVALID HYPOTHESIS”를 출력하고, 모순이 없다면 26개의 소문자로 알파벳들의 순서를 출력합니다. 만약 가능한 순서가 여러 개 있다면 아무 것이나 출력해도 좋습니다.</p>

<h3 id="풀이">풀이</h3>

<p>그래프 구조를 구현하고 깊이 우선 탐색을 통해 위상정렬된 결과를 구하는 문제이다. 알파벳의 순서에 따른 의존관계가 나타나므로 이를 그래프 구조로 표현하고 위상정렬을 수행할 수 있다. 순서대로 두 단어가 주어졌을 때, 단어의 순서를 결정하는 것은 단어의 앞에서부터 비교하여 처음으로 다른 두 알파벳 순서에 의해 결정되므로, 두 알파벳의 각 번호에 따른 연결 형태를 2차원 배열로써 구현할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">makeGraph</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">adj</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">length</span><span class="o">(),</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">).</span><span class="na">length</span><span class="o">());</span>
			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">!=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">).</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="o">{</span>
					<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
					<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">).</span><span class="na">charAt</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
					<span class="n">adj</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
					<span class="k">break</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>알파벳은 총 26개이므로, 각각의 알파벳 번호에 따른 연결 형태가 2차원 배열의 그래프 adj로 구현되었다. 이 때, 알파벳의 순서는 단방향으로 나타나게 된다. 이에 따른 위상정렬은 각 정점을 DFS방식으로 방문하였을 때 방문 순서로써 알아낼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">here</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">visited</span><span class="o">[</span><span class="n">here</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
				<span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="n">order</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">here</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>각 정점은 연결되어있는 다음 정점이 존재할 때마다 dfs가 재귀호출되어 가장 깊은 정점까지 호출되며, 마지막으로 방문한 가장 깊은 정점번호가 order 리스트에 기록된다. 따라서 이 order리스트를 뒤집었을 때 처음부터 방문한 순서인 알파벳 순서가 나타나게 된다. 이 때, 문제에서 순서가 모순인 경우는 단방향으로 표현된 각 정점간의 관계에서 반대쪽으로 가는 간선이 존재할 경우 모순이 발생하는데, 이는 각 정점들에서 반대쪽으로 가는 간선의 존재 여부를 검사함으로써 확인할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">sortAns</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
		<span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span>
				<span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="n">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">26</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span>
				<span class="k">if</span><span class="o">(</span><span class="n">adj</span><span class="o">[</span><span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)][</span><span class="n">order</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)]==</span><span class="mi">1</span><span class="o">)</span>
					<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">order</span><span class="o">;</span>

	<span class="o">}</span>
</code></pre></div></div>

<p>방문 순서가 저장된 리스트 order에서 i&lt;j인 order(j)-&gt;order(i)는 정렬된 방문순서에서 반대 방향으로의 방문을 나타내므로 이를 인접행렬 adj를 통해 반대 방향으로의 방문 가능여부를 파악할 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]28.그래프의 깊이 우선 탐색-단어 제한 끝말잇기</title>
	  <link>//WORDCHAIN</link>
	  <author></author>
	  <pubDate>2021-02-19T04:25:52+09:00</pubDate>
	  <guid>//WORDCHAIN</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/WORDCHAIN</p>

<p>끝말잇기는 참가자들이 원을 그리고 앉은 뒤, 시계 방향으로 돌아가면서 단어를 말하는 게임입니다. 이 때 각 사람이 말하는 단어의 첫 글자는 이전 사람이 말한 단어의 마지막 글자와 같아야 합니다. 단어 제한 끝말잇기는 일반적인 끝말잇기와 달리 사용할 수 있는 단어의 종류가 게임 시작 전에 미리 정해져 있으며, 한 단어를 두 번 사용할 수 없습니다. 단어 제한 끝말잇기에서 사용할 수 있는 단어들의 목록이 주어질 때, 단어들을 전부 사용하고 게임이 끝날 수 있는지, 그럴 수 있다면 어떤 순서로 단어를 사용해야 하는지를 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 게임에서 사용할 수 있는 단어의 수 N (1 &lt;= N &lt;= 100) 이 주어집니다. 그 후 N 줄에 하나씩 게임에서 사용할 수 있는 단어가 주어집니다. 각 단어는 알파벳 소문자로 구성되어 있으며, 길이는 2 이상 10 이하입니다. 중복으로 출현하는 단어는 없습니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄을 출력합니다. 만약 모든 단어를 사용하고 게임이 끝나는 방법이 없다면 “IMPOSSIBLE” 을 출력하고 (따옴표 제외), 방법이 있다면 사용할 단어들을 빈 칸 하나씩을 사이에 두고 순서대로 출력합니다. 방법이 여러 개 있다면 그 중 아무 것이나 출력해도 좋습니다.</p>

<h3 id="풀이">풀이</h3>

<p>풀이에 앞서 오일러 서킷 구조에 대한 이해가 필요하다. 오일러 서킷은 그래프의 모든 간선을 정확히 한번씩 지나 시작점으로 돌아오는 경로를 의미한다. 무향 그래프에서 오일러 서킷의 존재여부는 각 정점에 인접한 간선 수인 차수(degree)에 따라 결정될 수있는데, 모든 간선을 한번씩 지나기 위해서는 각 정점에서 들어간 횟수와 나간 횟수가 같아야 하므로 반드시 모든 정점의 차수가 짝수여야 한다. 그래프의 모든 간선을 지나도록 오일러 서킷을 찾는 방법은 깊이 우선 탐색인 DFS를 활용하여 다음과 같이 구현할  수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][]</span> <span class="n">adj</span><span class="o">;</span>
<span class="kt">void</span> <span class="nf">getEulerCircuit</span><span class="o">(</span><span class="kt">int</span> <span class="n">here</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">circuit</span><span class="o">){</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">there</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">there</span><span class="o">&lt;</span><span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">].</span><span class="na">length</span><span class="o">;</span><span class="n">there</span><span class="o">++)</span>
        <span class="k">while</span><span class="o">(</span><span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">][</span><span class="n">there</span><span class="o">]&gt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">][</span><span class="n">there</span><span class="o">]--;</span>
            <span class="n">adj</span><span class="o">[</span><span class="n">there</span><span class="o">][</span><span class="n">here</span><span class="o">]--;</span>
            <span class="n">getEulerCircuit</span><span class="o">(</span><span class="n">there</span><span class="o">,</span> <span class="n">circuit</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="n">circuit</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">here</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>각 정점간의 간선을 표현한 2차원 배열 adj에 대해 재귀호출로써 DFS를 구현하는데, 정점과 정점 사이에 간선이 존재할 때, 양쪽 간선을 모두 지우고 함수를 재귀호출한다. 이 때, 재귀 호출이 끝나고 함수가 반환될 때 정점번호를 리스트에 추가함으로써 역순으로 간선들이 추가된다. 따라서, 해당 리스트를 뒤집었을 때 오일러 서킷구조를 얻을 수 있다.</p>

<p>오일러 트레일은 모든 간선을 정확히 한번씩 지나지만 시작점과 끝점이 다른 경로를 의미한다. 오일러 트레일을 찾는 방법은 오일러 서킷 구조를 통해 알아낼 수 있는데, 점 a에서 b로 끝나는 오일러 트레일을 얻고자 할 때 b에서 a로의 간선을 임의로 추가한 뒤 오일러 서킷을 찾고, 해당 서킷에서 (b,a) 간선을 다시 끊는다면 a에서 b로 끝나는 오일러 트레일을 간단히 얻을 수 있다. 앞서 오일러 서킷은 모든 점이 짝수점이어야 존재할 수 있으므로, 트레일 구조에서는 시작점과 끝점을 제외하고 모든 정점이 짝수개의 차수를 가져야 하고, 시작점과 끝점의 경우 임의의 간선을 하나 추가해서 생각하였으므로 홀수개의 차수가 있어야 성립할 수 있다.</p>

<p>주어진 문제는 각 단어의 시작 단어와 끝단어가 그래프의 형태로 이어진다고 생각할 때, 단어들을 정확히 한 번씩 사용하여 모두 사용하는 방법을 찾아야 하므로 오일러 서킷 또는 트레일의 구조를 찾아내야 한다. 만약 각 단어를 정점으로써 생각한다면 모든 정점을 한번씩 방문하는 방식(헤밀토리니안 경로)으로 생각해야 되기 때문에, 오일러 구조로 접근하기 위해 각 단어의 시작/끝단어를 정점, 각 단어를 간선으로 표현한다면 오일러 서킷/트레일 구조와 같이 모든 간선(단어)을 정확히 한번씩 지나는 구조를 생각할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// graph[i][j] : i로 시작해서 j로 끝나는 단어목록</span>
<span class="c1">// adj[i][j] : i와 j사이의 간선수</span>
<span class="c1">// indegree, outdegree : 들어가고 나가는 차수</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">makeGraph</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>
	<span class="n">adj</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">][</span><span class="mi">26</span><span class="o">];</span>
	<span class="n">indegree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
	<span class="n">outdegree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="sc">'a'</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
			<span class="n">graph</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
		<span class="n">graph</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">].</span><span class="na">push</span><span class="o">(</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
		<span class="n">adj</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">]++;</span>
		<span class="n">outdegree</span><span class="o">[</span><span class="n">a</span><span class="o">]++;</span>
		<span class="n">indegree</span><span class="o">[</span><span class="n">b</span><span class="o">]++;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>주어진 단어 목록에 따른 그래프를 생성하는 함수는 위와 같다. 알파벳으로 주어진 각 단어의 시작, 끝 단어의 번호를 2차원 배열로써 생각한다면 특정 단어 i로 시작하고 j로 끝나는 복수개의 목록을 구현하여야 하므로, 2차원 배열 인덱스를 갖는 스택구조를 그래프로 구현할 수 있다. 이 때의 인접 행렬은 각 단어의 시작 단어번호, 끝 단어번호로써 표현될 수 있고, 유향 그래프이므로 각 단어인 정점에서 들어오는 차수와 나가는 차수를 별개로 계산하여야 한다. 시작단어에서 끝단어로 단어가 간선으로 표현되므로, 시작 단어의 나가는 차수와 끝 단어의 들어오는 차수가 각각 1씩 더해지게 된다.</p>

<p>유향 그래프에서의 오일러 서킷 존재 조건을 보면 각 정점에서 들어오는 간선과 나가는 간선의 수가 같아야 하므로, 들어오는 차수와 나가는 차수가 동일하다는 조건이 된다. 마찬가지로, 오일러 트레일의 경우 시작점, 끝점을 제외한 모든 정점의 나가는 차수, 들어오는 차수가 같고 시작점의 나가는 간선, 끝점의 들어오는 간선이 반대 간선보다 1개씩 많아야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">getEulerCircuit</span><span class="o">(</span><span class="kt">int</span> <span class="n">here</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">circuit</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">adj</span><span class="o">[</span><span class="n">here</span><span class="o">][</span><span class="n">i</span><span class="o">]--;</span>
			<span class="n">getEulerCircuit</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">circuit</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="n">circuit</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">here</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">getEulerTrailOrCircuit</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">circuit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
	<span class="c1">// 오일러 트레일을 찾아본다 -&gt; 시작점이 존재하는경우</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">outdegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">indegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">getEulerCircuit</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">circuit</span><span class="o">);</span>
			<span class="k">return</span> <span class="n">circuit</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="c1">// 트레일이 존재하지 않을 때 간선에 인접한</span>
	<span class="c1">// 아무 정점에서 시작하는 서킷을 찾는다.</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">outdegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">getEulerCircuit</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">circuit</span><span class="o">);</span>
			<span class="k">return</span> <span class="n">circuit</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="c1">// 모두 실패한 경우</span>
	<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>오일러 서킷을 구하는 함수 getEulerCircuit()은 앞서 구현한 무향그래프에서의 함수와 거의 동일한데, 유향의 경우 한 방향으로의 간선만을 생각해야 하므로 양쪽이 아닌 한쪽 방향의 간선을 지우게 된다. 문제에서 오일러 서킷 또는 트레일을 찾는 함수 getEulerTrailOrCircuit()은 먼저 특정 시작점이 존재하는 오일러 트레일을 찾고, 서킷이 존재하지 않을 때 아무 정점에서나 시작하는 서킷을 찾도록 구현한다. 트레일의 시작점에서 나가는 차수는 들어오는 차수보다 하나 더 많아야 하므로 이 조건을 만족하는 시작점을 찾아 트레일을 만든다. 시작점이 존재하지 않아 트레일을 만들 수 없을 때, 나가는 간선이 존재하는 아무 정점에서 시작하는 서킷을 찾게 된다. 이렇게 완성된 트레일 또는 서킷 탐색 함수를 통해 먼저 별도로 서킷/트레일의 존재여부를 검사하여 해당 함수를 호출하여 최종 목록을 얻을  수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkEuler</span><span class="o">()</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">plus1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">minus1</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">outdegree</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">indegree</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">delta</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
			<span class="n">plus1</span><span class="o">++;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">delta</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
			<span class="n">minus1</span><span class="o">++;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="o">(</span><span class="n">plus1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">minus1</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="n">plus1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">minus1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">String</span> <span class="nf">solve</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">makeGraph</span><span class="o">(</span><span class="n">words</span><span class="o">);</span>
	<span class="k">if</span> <span class="o">(!</span><span class="n">checkEuler</span><span class="o">())</span>
		<span class="k">return</span> <span class="s">"IMPOSSIBLE"</span><span class="o">;</span>
	<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">circuit</span> <span class="o">=</span> <span class="n">getEulerTrailOrCircuit</span><span class="o">();</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">circuit</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="n">words</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
		<span class="k">return</span> <span class="s">"IMPOSSIBLE"</span><span class="o">;</span>
	<span class="n">Collections</span><span class="o">.</span><span class="na">reverse</span><span class="o">(</span><span class="n">circuit</span><span class="o">);</span>
	<span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">circuit</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">circuit</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">graph</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">b</span><span class="o">].</span><span class="na">pop</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>오일러 트레일과 서킷의 존재여부를 검사하는 방법은 앞서 살펴본 차수에 따른 조건을 활용하면 된다. 서킷의 경우 모든 정점의 들어오는/나가는 차수가 같아야 하고 트레일의 경우 시작점과 끝점을 제외한 차수가 모두 같고 시작점, 끝점은 각각 하나씩 많아야 하므로, 함수에서 모든 정점들에 대해 차수를 계산하는 반복문을 통해 시작점, 끝점의 개수를 파악할 수 있다.</p>

<p>최종적으로 목록을 얻는 함수의 경우, 먼저 그래프를 만들고 트레일/서킷의 존재 여부를 검사한 뒤 트레일/서킷을 만들게 된다. 이 때 주의해야 할 점은 모든 간선을 방문하지 않아 그래프가 두개 이상으로 분리되는 경우가 발생할 수 있기 때문에 모든 간선의 방문여부 또한 검사하여야 한다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>[종만북]25.상호 베타적 집합-에디터 전쟁</title>
	  <link>//EDITORWARS</link>
	  <author></author>
	  <pubDate>2021-02-18T04:25:52+09:00</pubDate>
	  <guid>//EDITORWARS</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/EDITORWARS</p>

<p>에디터 전쟁은 가장 유명한 자유 소프트웨어 텍스트 편집기인 vi와 Emacs 중 어느 쪽이 더 우월한가를 놓고 인터넷에서 자주 벌어지는 논쟁을 말합니다. 이 논쟁에 참여하는 사람들은 서로 자신이 사용하는 편집기의 장점을 찬양하고 (“vi는 동작도 빠르고, 빠른 편집을 가능하게 한다고”, “Emacs는 LISP을 통해 확장 가능하다고”) 다른 편집기를 헐뜯곤 (“vi-vi-vi는 666이잖아! vi는 악마의 편집기야”, “Emacs는 좋은 운영 체제지. 좋은 편집기가 없는 것만 빼면 완벽해”) 합니다.</p>

<p>모든 회원들이 vi 혹은 Emacs를 사용하는 프로그래밍 동호회에서 연말 파티를 개최하려 합니다. 서로 다른 편집기를 사용하는 사람들이 파티에 함께 참가하면 싸움이 나기 때문에 vi를 사용하는 사람들만 오는 파티, Emacs를 사용하는 사람들만 오는 파티를 따로 하기로 했습니다. 이를 위해 지금까지 모든 회원들이 쓴 댓글을 모아 이들을 두 종류로 분류했습니다.</p>

<ol>
  <li>상호 인정: 이 유형의 댓글은 댓글을 쓴 사람과 원글을 쓴 사람이 같은 편집기를 쓴다는 사실을 의미합니다. 예로 “아이고 이런 편집기를 쓰시다니 뭘 아는 분이네” 혹은 “역시 편집기는 xxx가 짱이죠” 등이 있겠지요.</li>
  <li>상호 비방: 이 유형의 댓글은 댓글을 쓴 사람과 원글을 쓴 사람이 다른 편집기를 쓴다는 사실을 의미합니다. 예로 “그런 편집기 쓰면 손가락에 마비가 올 것 같네요” 혹은 “훠어이 악마의 편집기는 물러가라” 등이 있겠지요.</li>
</ol>

<p>이것만으로는 물론 각 사용자가 어떤 편집기를 쓰는지는 알 수 없지만, 우선 서둘러 장소를 예약해야 하기 때문에 이 정보만으로 파티에 올 수 있는 최대 인원을 알아야 합니다. 댓글 정보가 주어질 때 이 댓글 정보 중 모순되는 것은 없는지 확인하고, 모순되는 것이 없을 때 한 파티의 가능한 최대 인원을 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 회원의 수 N (1≤N≤10000)과 분석한 댓글의 개수 M (1≤M≤100000)이 주어집니다. 각 회원은 0에서 N - 1 범위의 숫자로 표현됩니다.</p>

<p>그 후 M줄에 하나씩 각 댓글의 정보가 주어집니다. 각 댓글은 상호 인정, 혹은 상호 비방 댓글입니다. 상호 인정 댓글은 “ACK a b”(0≤a, b&lt;N) 형태로 주어지며 상호 비방 댓글은 “DIS a b” 형태로 주어집니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄을 출력합니다.</p>

<ul>
  <li>
    <p>ᆞ댓글에 주어진 정보 중 모순이 없는 경우 한 파티에 올 수 있는 사람의 최대 수를 “MAX PARTY SIZE IS x”의 형태로 출력합니다.</p>
  </li>
  <li>
    <p>ᆞ댓글들에 주어진 정보 중 모순이 있는 경우, 모순이 처음으로 발생하는 댓글이 몇 번인지를 “CONTRADICTION AT i” 형태로 출력합니다. 댓글의 번호는 입력에 주어진 순서대로 1부터 시작한다고 합시다.</p>
  </li>
</ul>

<h3 id="풀이책-참고">풀이(책 참고)</h3>

<p>본 문제는 상호 배타적 집합을 표현하는 유니온-파인드 자료구조를 사용하여 해결하는 문제이다. 상호 배타적 집합은 전체 집합 중 성격이 같은 여러 개의 부분집합으로 쪼개진 자료구조를 의미한다. 각 부분집합은 공통원소가 없는 상호 배타적인 성격을 가진다. 이러한 상호 배타적 집합을 구현하기 위해 다음과 같은 3가지 연산이 필요하다.</p>

<ul>
  <li>초기화 : n개의 원소가 각각의 집합에 포함되어 있도록 초기화한다.</li>
  <li>합치기(union) 연산 : 두 원소 a, b가 주어질 때 이들이 속한 두 집합을 하나로 합친다.</li>
  <li>찾기(find) 연산 : 어떤 원소 a가 주어질 때 이 원소가 속한 집합을 반환한다.</li>
</ul>

<p>이를 구현한 기본적인 형태의 클래스는 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OptimizedDisjointSet</span> <span class="o">{</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>

	<span class="n">OptimizedDisjointSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">])</span>
			<span class="k">return</span> <span class="n">u</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
	<span class="o">}</span>

	<span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span>
			<span class="k">return</span> <span class="n">u</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">u</span><span class="o">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">==</span> <span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">])</span>
			<span class="o">++</span><span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>한 집합에 속하는 원소들을 하나의 트리로 묶어서 표현하는데, 공통 조상인 루트 노드를 기반으로 트리가 형성된다. 이 때, 두 원소가 같은 트리에 속해 있는지를 확인하는 방법은 각 원소가 포함된 트리의 루트를 찾아 비교하는 것이다. 따라서 이를 위해 각 노드의 부모 노드를 저장할 배열 parent가 존재한다. 노드의 초기화는 각 노드가 기본적으로 자기 자신으로 가르키도록 설정한다. 노드의 루트를 찾는 find 연산을 수행하면 해당 노드의 부모 노드를 따라 자기 자신을 가르키는 루트 노드에 도달할 때까지 재귀 호출되는데, 보다 효율적으로 찾기 위해 노드의 루트를 찾아 parent 배열에 저장하도록 한다. 이 과정에서, 재귀적으로 해당 루트 노드로 따라 올라갈때마다 각 노드의 parent 요소값은 루트로 설정되어 다음에 find연산을 수행하여도 곧바로 루트를 출력하도록 구현할 수 있다.</p>

<p>두 집합을 합치는 merge연산은 두 개의 트리 중 하나의 루트 노드의 부모를 다른 루트노드로 설정하는 방식으로 합치게 되는데, 합쳐진 결과가 고르게 퍼진 트리를 유지하기 위해서 각 트리의 높이를 계산해 높이가 낮은 트리를 높은 트리 밑에 추가하도록 함으로써 구현할 수 있다.</p>

<p>문제를 해결하기 위해 위의 구조를 확장하여 구현해야 하는데, 각 트리의 크기를 구해야 하므로 트리의 크기가 저장되는 size배열을 추가하고, 상호 비방의 경우 배타적 집합으로 설정해야 하므로 이를 저장할 enemy 배열을 추가한다. 그리고 입력값으로 주어진 상호 인정, 상호 비방에 따른 연산을 수행할 메서드를 각각 구현한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OptimizedDisjointSet</span> <span class="o">{</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">size</span><span class="o">;</span>
	<span class="kt">int</span><span class="o">[]</span> <span class="n">enemy</span><span class="o">;</span>

	<span class="n">OptimizedDisjointSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
		<span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
		<span class="n">enemy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
		<span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
		<span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">enemy</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">])</span>
			<span class="k">return</span> <span class="n">u</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
	<span class="o">}</span>

	<span class="kt">int</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">v</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
			<span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span>
			<span class="k">return</span> <span class="n">u</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">u</span><span class="o">;</span>
			<span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
			<span class="n">v</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="n">parent</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
		<span class="n">size</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+=</span> <span class="n">size</span><span class="o">[</span><span class="n">u</span><span class="o">];</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">==</span> <span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">])</span>
			<span class="o">++</span><span class="n">rank</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
		<span class="k">return</span> <span class="n">v</span><span class="o">;</span>

	<span class="o">}</span>

	<span class="kt">boolean</span> <span class="nf">dis</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">enemy</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>
		<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">enemy</span><span class="o">[</span><span class="n">u</span><span class="o">]);</span>
		<span class="n">enemy</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
		<span class="n">enemy</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kt">boolean</span> <span class="nf">ack</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="c1">// 두 집합이 적대 관계일 때 모순</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">enemy</span><span class="o">[</span><span class="n">u</span><span class="o">]</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">enemy</span><span class="o">[</span><span class="n">u</span><span class="o">],</span> <span class="n">enemy</span><span class="o">[</span><span class="n">v</span><span class="o">]);</span>
		<span class="n">enemy</span><span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
			<span class="n">enemy</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>초기화 단계에서 기본 사이즈는 1로, enemy는 없는 경우에 해당하는 -1로 각 배열을 초기화한다. merge연산의 리턴 타입은 int형으로 합쳐졌을 때 상위 루트에 해당하는 번호를 리턴하도록 한다. dis연산과 ack 연산을 구현하는데, 책에서 정의한 핵심 원칙은 다음과 같다.</p>

<ul>
  <li>동지의 적은 나의 적이다 : 나와 상대가 같은 편집기를 쓸 때, 상대와 다른 편집기를 쓰는 사람은 나와 다른 편집기를 쓴다.</li>
  <li>적의 적은 나의 동지다 : 나와 상대가 다른 편집기를 쓸 때, 상대와 다른 편집기를 쓰는 사람은 나와 같은 편집기를 쓴다.</li>
</ul>

<p>위 두가지 성질을 이용하면, ack연산과 dis연산에서 이를 활용하여 enemy배열을 통해 적대 관계와 merge연산을 통해 합치기 연산이 가능하며, 모순이 발생한 경우를 체크할 수있다. ack 연산의 경우 두 루트노드를 합치고, 두 루트의 적대 노드를 합쳐 생성된 두 트리에 대해 서로간의 적대 관계를 설정하여 “동지의 적은 나의 적” 원칙을 활용하였다. dis연산의 경우 각 노드와 상대 노드의 적대 노드를 합쳐 생성된 두 트리의 적대 관계를 설정하여 “적의 적은 나의 동지” 원칙을 활용하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">maxParty</span><span class="o">(</span><span class="n">OptimizedDisjointSet</span> <span class="n">set</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">node</span> <span class="o">&lt;</span> <span class="n">N</span><span class="o">;</span> <span class="n">node</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">parent</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">==</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">enemy</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">enemy</span><span class="o">[</span><span class="n">node</span><span class="o">];</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">enemy</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">)</span>
					<span class="k">continue</span><span class="o">;</span>
				<span class="kt">int</span> <span class="n">mySize</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">[</span><span class="n">node</span><span class="o">];</span>
				<span class="kt">int</span> <span class="n">enemySize</span> <span class="o">=</span> <span class="o">(</span><span class="n">enemy</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">[</span><span class="n">enemy</span><span class="o">]);</span>
				<span class="n">ret</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">mySize</span><span class="o">,</span> <span class="n">enemySize</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>입력값에 따라 ack연산과 dis 연산이 수행되며, 완료되었을 때 최종적으로 위에서 구현한 상호 배타적 집합을 활용해 최대 집합의 크기를 계산하는 메소드 maxParty를 구현한다. 모든 사람에 대해 반복문을 돌며 부모 노드가 자기 자신을 가르키는 루트 노드를 찾아 크기를 계산하는데, 같은 모임 쌍을 두번 세지 않기 위해 적대 관계의 노드 번호가 노드 번호보다 작은 경우만을 세도록 한다. 해당 트리의 크기와, 적대 노드의 트리 크기를 계산하여 최댓값을 계산하고, 이를 누적하여 가장 큰 집합의 크기를 계산하였다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]24.구간 트리-삽입 정렬 시간 재기</title>
	  <link>//MEASURETIME</link>
	  <author></author>
	  <pubDate>2021-02-18T04:25:52+09:00</pubDate>
	  <guid>//MEASURETIME</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/MEASURETIME</p>

<p>유명한 정렬 알고리즘인 삽입 정렬은 정렬된 부분 배열을 유지하며 이 배열에 새 원소를 삽입해 나가는 식으로 동작합니다. 주어진 정수 배열 A를 정렬하는 삽입 정렬의 구현은 다음과 같습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertionSort</span><span class="o">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// A[0..i-1] 에 A[i] 를 끼워넣는다</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
      <span class="c1">// 불변식 a: A[j+1..i] 의 모든 원소는 A[j] 보다 크다.</span>
      <span class="c1">// 불변식 b: A[0..i] 구간은 A[j] 를 제외하면 정렬되어 있다.</span>
      <span class="n">swap</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">A</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
      <span class="o">--</span><span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>삽입 정렬은 A[0..i-1] 이 정렬된 배열일 때, A[i] 를 적절한 위치를 만날 때까지 왼쪽으로 한칸씩 움직입니다. 예를 들어 A={5,1,4,3,2} 의 삽입 정렬은 다음과 같이 이루어집니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">A</th>
      <th style="text-align: center">비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">5 1 4 3 2</td>
      <td style="text-align: center">초기 상태</td>
    </tr>
    <tr>
      <td style="text-align: center">1 5 4 3 2</td>
      <td style="text-align: center">1을 왼쪽으로 1칸 옮김</td>
    </tr>
    <tr>
      <td style="text-align: center">1 4 5 3 2</td>
      <td style="text-align: center">4를 왼쪽으로 1칸 옮김</td>
    </tr>
    <tr>
      <td style="text-align: center">1 3 4 5 2</td>
      <td style="text-align: center">3을 왼쪽으로 2칸 옮김</td>
    </tr>
    <tr>
      <td style="text-align: center">1 2 3 4 5</td>
      <td style="text-align: center">2를 왼쪽으로 3칸 옮김</td>
    </tr>
  </tbody>
</table>

<p>길이 N 인 수열 A[] 가 주어집니다. 이 정렬 과정에서 숫자들을 총 몇 번이나 옮기는지를 계산하는 프로그램을 작성하세요. 예를 들어 위 배열의 경우 총 1+1+2+3=7 번 숫자를 옮기게 됩니다.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 원 배열의 길이 N (1 &lt;= N &lt;= 50000) 이 주어집니다. 그 다음 줄에 N개의 정수로 A의 원소 Ai가 주어집니다. (0 &lt;= Ai &lt; 1,000,000)</p>

<p><strong>입력의 양이 많으므로 가능한 빠른 입력 함수를 사용하는 것이 좋습니다.</strong></p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄에 A를 삽입정렬하는 과정에서 숫자를 옮기는 총 횟수를 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>이 문제는 펜윅 트리를 활용하여 푸는 문제인데, 펜윅트리는 빠르고 간단하게 구간합을 계산하기 위한 트리 구조이다. 구현은 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FenwickTree</span><span class="o">{</span>
	<span class="kt">int</span> <span class="n">tree</span><span class="o">[];</span>
	
	<span class="n">FenwickTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
		<span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
	<span class="o">}</span>
	
	<span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 비트연산을 위해 인덱스를 1부터 생각</span>
		<span class="o">++</span><span class="n">pos</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">ret</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">[</span><span class="n">pos</span><span class="o">];</span>
			<span class="n">pos</span> <span class="o">&amp;=</span> <span class="o">(</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">pos</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
		<span class="o">++</span><span class="n">pos</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(</span><span class="n">pos</span> <span class="o">&lt;</span><span class="n">tree</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">tree</span><span class="o">[</span><span class="n">pos</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="o">(</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">pos</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>	
	
<span class="o">}</span>
</code></pre></div></div>

<p>1차원 배열 tree에 각 요소값이 저장되며, sum과 add메소드에 비트연산을 통해 적절한 배열 범위에 접근할 수 잇다. 이 때, 시작 인덱스를 비트연산을 수행하기 위해 1로 설정하기 위해 인덱스에 1을 더하여 연산한다. 합치는 연산 sum의 경우 pos &amp; pos-1 을 통해 이진수의 마지막 비트를 지운 구간을 계산하여 부분합의 다음 요소에 접근하고, 더하는 연산 add의 경우 pos &amp; -pos를 통해 맨 오른쪽이 1인 비트를 스스로에게 더한 값을 계산하여 자신을 포함하는 다음 요소에 접근한다. 이렇게 구현한 펜윅 트리를 통해 부분합을 빠르게 계산할 수 있다.</p>

<p>문제의 경우, 배열에서 삽입정렬이 수행될 때 A[0…i-1] 구간까지 A[i]보다 큰 값이 몇 개 있는지 파악해야 한다. 따라서, 앞서 구현한 펜윅트리에 각 숫자의 등장 횟수를 순차적으로 저장하도록 한다. 배열의 첫 요소부터 시작하여 모든 숫자의 등장 횟수 중 A[i]까지의 등장 횟수의 부분합을 빼서 A[i]보다 큰 값들의 등장 횟수를 계산하고, 각 요소값에 등장 횟수를 1씩 더한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">double</span> <span class="nf">countMoves</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">FenwickTree</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FenwickTree</span><span class="o">(</span><span class="mi">1000000</span><span class="o">);</span>
		<span class="kt">double</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">ret</span><span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">999999</span><span class="o">)-</span><span class="n">tree</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
			<span class="n">tree</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre></div></div>

<p>문제에서 주어진 입력값의 범위가 100만까지이므로 999999까지의 합은 전체 숫자의 등장 횟수고, A[i]까지의 부분합은 A[i] 까지의 등장 횟수의 부분합이므로 두 값을 빼면 삽입 정렬이 일어나는 조건인 더 큰 값의 개수를 구할 수 있다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>[종만북]22.이진 검색 트리-너드인가, 너드가 아닌가?</title>
	  <link>//NERD2</link>
	  <author></author>
	  <pubDate>2021-02-17T04:25:52+09:00</pubDate>
	  <guid>//NERD2</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/NERD2</p>

<p>대 성황이었던 지난 알고스팟 연간 모의고사 이후 프로그래밍 대회의 열기는 날로 뜨거워져 올해는 10만명이 넘는 사람들이 참가 신청을 할 것으로 예상되고 있습니다. 그러나 채점관을 할 자원 봉사자는 예년과 똑같이 5명뿐이라, 이 사람들을 대회에 다 참가시킬 수는 없습니다. 따라서 올해에도 참가 신청을 한 사람 중 진정한 프로그래밍 너드들만을 대회에 참가할 수 있도록 받아 주기로 했습니다.</p>

<p>종만의 새로운 이론에 따르면, 어떤 사람의 너드 지수는 다음 두 가지 값에 의해 결정됩니다.</p>

<ul>
  <li>알고스팟 온라인 채점 시스템에서 푼 문제의 수 p</li>
  <li>밤 새면서 지금까지 끓여먹은 라면 그릇 수 q</li>
</ul>

<p>이 이론에 따르면 어떤 참가 신청자 a 의 문제 수 pa 와 그릇 수 qa 를 다른 참가 신청자 b 의 문제 수 pb 와 그릇 수 qb 에 각각 비교했을 때, pa &lt; pb, qa &lt; qb 라면 참가 신청자 a 는 너드일 가능성이 없습니다. 조직위는 너드일 가능성이 있는 사람들만을 대회에 받아주기로 했습니다.</p>

<p>한 사람의 참가 가능 여부는 다른 사람들에 의해 결정되기 때문에, 대회에 참가할 수 있는 사람의 수는 새로운 사람이 참가 신청을 할 때마다 계속 바뀝니다. 예를 들어 다음과 같은 4명의 사람들이 순서대로 참가 신청을 했다고 합시다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">참가자</th>
      <th style="text-align: center">종만</th>
      <th style="text-align: center">재훈</th>
      <th style="text-align: center">효승</th>
      <th style="text-align: center">광규</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">문제 수</td>
      <td style="text-align: center">72</td>
      <td style="text-align: center">57</td>
      <td style="text-align: center">74</td>
      <td style="text-align: center">64</td>
    </tr>
    <tr>
      <td style="text-align: center">라면 그릇 수</td>
      <td style="text-align: center">50</td>
      <td style="text-align: center">67</td>
      <td style="text-align: center">55</td>
      <td style="text-align: center">60</td>
    </tr>
  </tbody>
</table>

<p>종만과 재훈이 순서대로 대회 참가 신청을 하면 대회에 참가할 수 있는 사람의 수는 각각 1, 2 로 늘어나지만, 효승이는 문제 수도 라면 그릇 수도 종만보다 많으므로 효승이 참가 신청을 한 시점에서 종만은 더 이상 대회에 참가할 수 없습니다. 따라서 이 네 명이 참가 신청을 할 때마다 참가 가능자의 수는 1, 2, 2, 3으로 변합니다.</p>

<p>이렇게 각 사람이 참가 신청을 할 때마다 대회에 참가할 수 있는 사람들의 수가 어떻게 변하는지 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 참가 신청한 사람들의 수 N (1 &lt;= N &lt;= 50000) 이 주어집니다. 그 후 N 줄에 각 2개의 정수로 각 사람의 문제 수 pi 와 라면 그릇 수 qi 가 참가 신청한 순서대로 주어집니다 (0 &lt;= pi,qi &lt;= 100000) . 두 사람의 문제 수나 라면 그릇 수가 같은 경우는 없다고 가정해도 좋습니다.
입력의 양이 많으므로 가능한 빠른 입력 함수를 사용하는 것이 좋습니다.</p>

<h4 id="출력">출력</h4>

<p>각 사람이 참가 신청을 할 때마다 대회 참가 자격이 되는 사람의 수를 계산한 뒤, 각 테스트 케이스마다 그 합을 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>주어진 입력값이 중복값이 존재하지 않은 두 숫자 쌍이므로, 이진 검색트리를 통해 효율적인 범위 검색이 가능하다. 새로운 참가자가 주어졌을 때, 기존 참가자 중 문제수와 라면그릇수가 더 큰 참가자가 존재하여 참가할 수 없는경우와, 참가할 때 자신보다 문제수와 라면 그릇수가 더 작은 참가자들이 존재하는 경우 두 가지를 고려하는 것이 핵심이다. 특히, 중요한 것은 참가자들을 문제수를 기준으로 오름차순으로 정렬된 형태를 생각할 때, 각 참가자들의 그릇수는 내림차순의 형태를 나타나게 된다. 만약 p1&lt;p2일 때, q1&lt;q2이면 1번이 2번보다 모두 작은 경우이므로 모순되기 때문에, 문제수에 따라 정렬된 이진 트리를 생각할 때 그릇수는 반대로 정렬된다는 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 새로 입력된 문제 수 p, 그릇 수 q, 이진 검색 트리 map</span>
<span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">higherKey</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">dish</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">higherKey</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">dish</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
		<span class="k">continue</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">);</span>
<span class="k">while</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">lowerKey</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">dish</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">lowerKey</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">dish</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">)</span>
		<span class="k">break</span><span class="o">;</span>
	<span class="k">else</span>
		<span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">lowerKey</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
<span class="o">}</span>
<span class="n">sum</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</code></pre></div></div>

<p>이진 검색트리 map을 구현하고, 먼저 참가자가 대회에 참가할 수 있는 여부를 검사해야 한다. 이는 트리에 참가자보다 문제수와 그릇수가 더 많은 참가자의 존재여부로 파악할 수 있다. map은 문제수를 키값으로 하여 정렬된 이진 검색트리인데, 입력된 문제 수 p보다 더 큰값이 존재하는지를 higherKey 메소드를 통해 알아내며 존재할 경우, p보다 큰 값중 가장 작은값은 그릇수가 가장 큰 경우에 해당하므로 해당 참가자의 그릇수가 q보다 클 때 참가할 수 없는 경우가 되기 때문에 현재 트리의 크기를 합산하고 종료한다.</p>

<p>이에 해당되지 않는 경우는 map에 (p,q)를 추가하며 (p,q)보다 작은 값들을 찾아내어 트리에서 제거하여야 한다. 이는 일일이 순회하며 파악할 필요 없이, 문제수 p보다 작은 값 중 최댓값은 그릇수가 나머지중 최소이므로 해당 그릇수가 q보다 작은지 여부를 검사하여, 작은 경우 해당 참가자를 제거하고 다시 p보다 작은 최댓값을 다음값으로 갱신하는 과정을 반복함으로써 (p,q)쌍보다 작은 값들을 차례로 제거할 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]24.구간 트리-등산로</title>
	  <link>//MORDOR</link>
	  <author></author>
	  <pubDate>2021-02-17T04:25:52+09:00</pubDate>
	  <guid>//MORDOR</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/MORDOR</p>

<p>모르도르 지방의 <a href="http://en.wikipedia.org/wiki/Mordor#Geography">아름다운 경치</a>를 한 눈에 볼 수 있는 명산 <a href="http://en.wikipedia.org/wiki/Orodruin#Adaptations">오로드루인</a>에는 길기로 유명한 등산로가 있습니다. 이 등산로는 산등성이를 따라 오르락내리락하며 구성되어 있지요. 이 등산로는 너무 길기 때문에 특수 장비(예를 들면, <a href="http://en.wikipedia.org/wiki/One_Ring">절대반지</a> 등)를 갖춘 사람이 아니라면 처음부터 끝까지 정복하기가 힘이 듭니다. 관광 자원 개척을 위해 이 등산로 중 몇 군데를 별도의 등산로로 개방하려고 합니다.</p>

<p>등산로에는 100미터 간격으로 표지판이 있는데, 각 표지판의 해발 고도를 측정한 자료가 있습니다. 이 때 등산로의 난이도는 등산로를 가다 만나는 표지판 중 최대 해발 고도와 최저 해발 고도의 차이입니다. 개방을 검토하고 있는 등산로의 일부가 주어질 때, 각 부분의 난이도를 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 30) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 원래 등산로에 있는 표지판의 수 N (1 &lt;= N &lt;= 100,000)과 개방을 고려하고 있는 등산로의 수 Q (1 &lt;= Q &lt;= 10,000)가 주어집니다. 그 다음 줄에 N 개의 정수로 각 표지판의 해발 고도 hi 가 순서대로 주어집니다. (0 &lt;= hi &lt;= 20,000) 각 표지판은 입력에 주어지는 순서대로 0 번부터 N-1 번까지 번호가 매겨져 있습니다. 그 다음 Q 줄에 각 2개의 정수로 개방을 고려하고 있는 등산로의 첫 번째 표지판과 마지막 표지판의 번호 a , b (0 &lt;= a &lt;= b &lt; N) 가 주어집니다.</p>

<p><strong>입력 데이터의 양이 많으니 가능한 빠른 입출력 방법을 사용하시기 바랍니다.</strong></p>

<h4 id="출력">출력</h4>

<p>한 줄에 하나씩 개방을 고려하고 있는 각 등산로의 난이도를 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>구간트리를 활용한 문제로, 각 구간에서 최솟값을 구하는 구간트리와 최댓값을 구하는 구간트리를 구현한 뒤, 주어진 구간에서 각 트리를 활용해 최댓값과 최솟값의 차이를 계산한다. 최솟값을 구하는 구간트리의 구조는 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SegmentTree</span> <span class="o">{</span>

	<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">segmentArr</span><span class="o">;</span> 

    <span class="n">SegmentTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">segmentArr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span><span class="o">];</span>

        <span class="n">init</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// node를 root로 하는 서브트리를 초기화하고, 이 구간의 최소치를 반환한다</span>
    <span class="kt">int</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">return</span> <span class="n">segmentArr</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">leftMin</span> <span class="o">=</span> <span class="n">init</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">rightMin</span> <span class="o">=</span> <span class="n">init</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">node</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">segmentArr</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">leftMin</span><span class="o">,</span> <span class="n">rightMin</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nodeLeft</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nodeRight</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">nodeLeft</span> <span class="o">||</span> <span class="n">nodeRight</span> <span class="o">&lt;</span> <span class="n">left</span><span class="o">)</span>
    		<span class="k">return</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    	<span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;=</span><span class="n">nodeLeft</span> <span class="o">&amp;&amp;</span> <span class="n">nodeRight</span><span class="o">&lt;=</span><span class="n">right</span><span class="o">)</span>
    		<span class="k">return</span> <span class="n">segmentArr</span><span class="o">[</span><span class="n">node</span><span class="o">];</span>
    	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">nodeLeft</span> <span class="o">+</span> <span class="n">nodeRight</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    	<span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">query</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">nodeLeft</span><span class="o">,</span> <span class="n">mid</span><span class="o">),</span> <span class="n">query</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">nodeRight</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="nf">query</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>전체 요소는 1차원 배열에 저장되며, 노드 번호를 통해 접근한다. 트리의 초기화함수 init를 통해 루트 노드와 아래의 왼쪽 노드, 오른쪽 노드가 초기화하는 함수를 재귀적으로 호출하여 구현되었는데, 이 떄 왼쪽 노드값과 오른쪽 노드값의 최솟값을 해당 노드의 최솟값으로 계산하는 방식으로 구현된다. 그리고 특정 구간의 최솟값을 계산하는 함수 query에서 각 구간을 절반씩 쪼개어 재귀호출하는 방식으로 해당 구간의 최솟값을 계산하는 것을 볼 수 있다.</p>

<p>최댓값을 계산하는 트리는 위 클래스에서 노드의 최솟값을 최댓값으로 변경하여 구현할 수 있다. 따라서, 이 트리들을 통해 문제에서 주어진 특정 구간의 최댓값과 최솟값을 쉽게 계산할 수 있다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]23.우선순위 큐와 힙-변화하는 중간값</title>
	  <link>//RUNNINGMEDIAN</link>
	  <author></author>
	  <pubDate>2021-02-17T04:25:52+09:00</pubDate>
	  <guid>//RUNNINGMEDIAN</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/RUNNINGMEDIAN</p>

<p>한 수열의 중간값(median)은 이 수열을 정렬했을 때 가운데 오는 값입니다. 예를 들어 {3,1,5,4,2}를 정렬했을 때 가운데 오는 값은 3이지요. 수열의 길이가 짝수일 때는 가운데 있는 두 값 중 보다 작은 것을 수열의 중간값이라고 정의하도록 합시다.</p>

<p>한 수열의 중간값은 수열에 새로운 수가 추가될 때마다 바뀔 수 있습니다. 텅 빈 수열에서 시작해서 각 수가 추가될 때마다 중간값을 계산하는 프로그램을 작성하세요. 예를 들어 3, 1, 5, 4, 2 순서대로 숫자가 추가될 경우 수열의 중간값은 3, 1, 3, 3, 3 순서로 변화합니다.</p>

<h3 id="입력-생성">입력 생성</h3>

<p>입력의 크기가 큰 관계로, 이 문제에서는 수열을 입력받는 대신 다음과 같은 식을 통해 프로그램 내에서 직접 생성합니다.</p>

<ul>
  <li>A[0] = 1983</li>
  <li>A[i] = (A[i-1] * a + b) % 20090711</li>
</ul>

<p>a와 b는 입력에 주어지는 상수입니다. 이 문제의 해법은 입력을 생성하는 방식과는 아무 상관이 없습니다.</p>

<h4 id="입력">입력</h4>

<p>입력 파일의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 20)가 주어지고, 그 후 C줄에 각 3개의 정수로 수열의 길이 N (1 &lt;= N &lt;= 200,000), 그리고 수열을 생성하는 데 필요한 두 정수 a , b (0 &lt;= a,b &lt;= 10000) 가 주어집니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄에 N개의 중간값의 합을 20090711로 나눈 나머지를 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>우선순위 큐를 활용하여 중간값을 추출할 수 있는데, 수열 중 중간값 mid를 기준으로 작은 왼쪽 부분수열에 대한 우선순위큐와, 큰 오른쪽 부분수열에 대한 우선순위큐를 구현한다. 이 때, 왼쪽 부분수열은 가장 큰 값을 추출하기 위해 크기가 큰 값 순으로 저장되는 우선순위큐를, 오른쪽 부분수열은 가장 작은 값을 추출하기 위해 크기가 작은 값으로 저장되는 우선순위큐를 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="mi">1983</span><span class="o">;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">1983</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">else</span> <span class="o">{</span>
		<span class="n">num</span> <span class="o">=</span> <span class="o">((</span><span class="n">num</span> <span class="o">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">pq_left</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
				<span class="n">pq_right</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
				<span class="n">mid</span> <span class="o">=</span> <span class="n">pq_left</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="o">}</span> <span class="k">else</span>
				<span class="n">pq_right</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">pq_right</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
				<span class="n">pq_left</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
				<span class="n">mid</span> <span class="o">=</span> <span class="n">pq_right</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="o">}</span> <span class="k">else</span>
				<span class="n">pq_left</span><span class="o">.</span><span class="na">add</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">num</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="n">sum</span> <span class="o">+=</span> <span class="n">mid</span><span class="o">;</span>
<span class="n">sum</span> <span class="o">%=</span> <span class="n">MOD</span><span class="o">;</span>
</code></pre></div></div>

<p>수열에 새로운 수가 들어올 때 mid값이 변화하는 경우는 홀/짝의 경우와 mid값의 대소에 따라 결정된다.</p>

<p>수열의 개수를 기준으로 값이 추가되었을 때, 짝수의 경우는 중간값보다 작은 값이 들어온 경우 해당 값을 왼쪽 큐에 추가하고 기존 mid값을 오른쪽 큐에 추가 한 다음, 왼쪽 큐 중 가장 큰 값을 꺼내 mid값으로 설정하여 mid값이 오른쪽으로 밀리는 것을 구현한다. 홀수의 경우는 중간값보다 큰 값이 들어온 경우 오른쪽 큐에 추가하고 기존 mid값을 왼쪽 큐에 추가한 다음, 오른쪽 큐 중 가장 작은 값ㅇ르 꺼내 mid값으로 설정하여 mid값이 왼쪽으로 밀리는 것을 구현한다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]21.트리의 구현과 순회-요새</title>
	  <link>//FORTRESS</link>
	  <author></author>
	  <pubDate>2021-02-16T04:25:52+09:00</pubDate>
	  <guid>//FORTRESS</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/FORTRESS</p>

<p><img src="http://algospot.com/media/judge-attachments/6b98991b489acef77ed1b63dc31bc32f/castle.svg.png" alt="" /></p>

<p>중세의 성과 요새들은 보안을 튼튼히 하면서도 더 넓은 영역을 보호하기 위해 여러 개의 성벽을 갖고 있었다고 하지요. 전세계에서 가장 편집증이 심한 영주가 지은 스트로고(<a href="http://en.wikipedia.org/wiki/Hogwarts">Strawgoh</a>) 요새는 이의 극치를 보여줍니다. 이 요새는 그림과 같이 커다란 원형 외벽 내에 여러 개의 원형 성벽이 겹겹이 지어진 형태로 구성되어 있는데, 어떤 성벽에도 문이 없어서 성벽을 지나가려면 사다리를 타고 성벽을 오르내려야 합니다. 요새 내에서도 한 곳에서 다른 곳으로 이동하는 데 시간이 너무 오래 걸린다는 원성이 자자해지자, 영주는 요새 내에서 왕래가 불편한 곳들을 연결하는 터널을 만들기로 했습니다. 계획을 세우기 위해 요새 내에서 서로 왕래하기 위해 가장 성벽을 많이 넘어야 하는 두 지점을 찾으려고 합니다. 예를 들어 위 그림의 경우, 별표로 표시된 두 지점 간을 이동하기 위해서는 다섯 번이나 성벽을 넘어야 하지요.</p>

<p>성벽들의 정보가 주어질 때 가장 성벽을 많이 넘어야 하는 두 지점 간을 이동하기 위해 몇 번이나 성벽을 넘어야 하는지 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1 &lt;= C &lt;= 100) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 성벽의 수 N (1 &lt;= N &lt;= 100) 이 주어집니다. 그 후 N 줄에는 각 3개의 정수로 각 성벽의 위치와 크기에 대한 정보 xi , yi , ri 가 주어집니다. (0 &lt;= xi, yi &lt;= 1000,1 &lt;= ri &lt;= 1000,0 &lt;= i&lt;N) 이 때 i 번 성벽은 (xi, yi) 를 중심으로 하는 반지름 ri 인 원형으로 설치되어 있습니다. 편의상 모든 성벽의 두께는 0이라고 가정하며, 입력에 주어지는 성벽들은 서로 겹치거나 닿지 않습니다. 입력에 주어지는 첫 번째 성벽은 외벽이며, 외벽은 입력에 주어지는 모든 다른 성벽을 포함합니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄에 두 지점 간 이동을 위해 최대 몇 번이나 성벽을 넘어야 하는지를 출력하세요.</p>

<h3 id="풀이책-참고">풀이(책 참고)</h3>

<p>문제의 원 모양을 보면 각 원마다 포함하고 있는 하위 원들이 있으므로, 이를 트리구조로 변환하여 풀 수 있다. 맨 위의 루트에서 잎과 잎 사이의 간격 중 가장 긴 것이 답으로 볼 수 있는데, 좌표형태로 표현된 입력값을 트리구조로 변환하는 작업과 두 원간의 포함관계를 표현하는 것이 까다로웠다.</p>

<p>먼저, 주어진 좌표들과 반지름으로 구성된 원을 트리로 표현하는 함수를 구현한다. 이 때 중요한 것은, 각 원간의 포함관계를 확인하는 함수가 필요한데, 원과 원 사이에 다른 원이 없이 직접적으로 포함하였는지 여부만을 확인해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
	<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span> <span class="n">children</span><span class="o">;</span>
	<span class="n">Tree</span><span class="o">(){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;();</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="n">Tree</span> <span class="nf">makeTree</span><span class="o">(</span><span class="kt">int</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Tree</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Tree</span><span class="o">();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">isChild</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span>
				<span class="n">t</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">makeTree</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
		<span class="k">return</span> <span class="n">t</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>맨 첫번째 입력이 외벽이므로, 0번 원(성벽)이 루트 노드가 된다. makeTree함수를 통해 루트 노드의 번호를 입력받았을 때, 모든 노드를 순회하여 해당 노드와 포함여부를 체크하는 isChild함수를 통해 직접적으로 포함되었을 경우 해당 노드의 자식으로 추가하도록 구현하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">pow</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isIn</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">R</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">R</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">pow</span><span class="o">(</span><span class="n">X</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">-</span> <span class="n">X</span><span class="o">[</span><span class="n">p</span><span class="o">])</span> <span class="o">+</span> <span class="n">pow</span><span class="o">(</span><span class="n">Y</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">-</span> <span class="n">Y</span><span class="o">[</span><span class="n">p</span><span class="o">]))</span> <span class="o">&lt;</span> <span class="n">pow</span><span class="o">(</span><span class="n">R</span><span class="o">[</span><span class="n">p</span><span class="o">]</span> <span class="o">-</span> <span class="n">R</span><span class="o">[</span><span class="n">c</span><span class="o">]);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isChild</span><span class="o">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span><span class="o">(!</span><span class="n">isIn</span><span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="n">c</span><span class="o">))</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">isIn</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isIn</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span>
			<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>두 원간의 포함여부를 확인하는 함수 isChild를 구현하는데, 두 원의 포함여부는 각 반지름과 중심간의 거리를 통해 확인할 수 있다. 특히, 모든 노드를 검사하여 두 노드 사이에 포함된 또다른 원이 존재할 경우 직접 포함관계가 아니므로 false를 리턴하도록 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="n">Tree</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Vector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">heights</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
			<span class="n">heights</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">children</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
		<span class="k">if</span><span class="o">(</span><span class="n">heights</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
			<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
		<span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">heights</span><span class="o">);</span>
		<span class="k">if</span><span class="o">(</span><span class="n">heights</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;=</span><span class="mi">2</span><span class="o">)</span>
			<span class="n">longest</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">longest</span><span class="o">,</span> 							<span class="mi">2</span><span class="o">+</span><span class="n">heights</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">heights</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">2</span><span class="o">)+</span><span class="n">heights</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">heights</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">));</span>
		<span class="k">return</span> <span class="n">heights</span><span class="o">.</span><span class="na">lastElement</span><span class="o">()+</span><span class="mi">1</span><span class="o">;</span>

<span class="o">}</span>

<span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="n">Tree</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">longest</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">longest</span><span class="o">,</span> <span class="n">h</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>트리 구조 구현을 마치면, 주어진 트리에서 가장 긴 경로를 탐색하여야 한다. 입력받은 노드에 대하여 해당 트리의 높이를 반환하는 함수 height를 구현하는데, 이 때 가장 긴 경로는 잎과 잎사이 길이의 최댓값 또는 전체 트리의 높이이므로, height 함수에서 잎과 잎 사이의 길이의 최댓값을 재귀적으로 찾도록 한다. 이는, 입력받은 트리에 대해 자식들의 높이 중 가장 긴 높이와, 그다음으로 긴 높이의 합을 더한 값이 되므로, 입력받은 노드의 자식들을 모아 정렬하고 해당 두 값을 찾아 최댓값을 검색하도록 구현할 수 있다. 이 때, 전체 경로는 루트 노드또한 포함하여야 하므로 각각 1씩 더하여 계산된다.</p>


	  ]]></description>
	</item>

	<item>
	  <title>[종만북]21.트리의 구현과 순회-문자열 합치기</title>
	  <link>//TRAVERSAL</link>
	  <author></author>
	  <pubDate>2021-02-15T04:25:52+09:00</pubDate>
	  <guid>//TRAVERSAL</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/TRAVERSAL</p>

<p>트리를 순회하는 알고리즘은 트리의 모든 노드들을 특정 순서에 맞춰 방문하지만, 트리는 배열처럼 1차원적인 구조가 아니기 때문에 단 한 가지의 당연한 순서가 존재하지 않습니다. 때문에 필요에 맞춰 순서를 정의해야 합니다. 이진 트리(binary tree)는 모든 노드에 왼쪽과 오른쪽, 최대 두 개의 자손이 있는 트리를 말하는데, 이진 트리의 순회 순서 중 유명한 세 가지로 전위 순회(preorder traverse), 중위 순회(inorder traverse) 그리고 후위 순회(postorder traverse)가 있습니다. 이들은 모두 왼쪽 서브트리를 오른쪽보다 먼저 방문한다는 점에선 같지만, 트리의 루트를 언제 방문하는지가 서로 다릅니다.</p>

<p>전위 순회는 맨 처음에 트리의 루트를 방문하고, 왼쪽과 오른쪽 서브트리를 순서대로 방문합니다. 중위 순회는 왼쪽과 오른쪽 서브트리 사이에 트리의 루트를 방문하고, 후위 순회는 왼쪽과 오른쪽 서브트리를 모두 방문한 뒤에야 루트를 방문합니다.</p>

<p>다음 그림은 이진 트리의 한 예를 보여 줍니다. 이 트리를 전위 순회하면 모든 노드를 27, 16, 9, 12, 54, 36, 72의 순서대로 방문하게 됩니다. 반면 중위 순회했을 때는 9, 12, 16, 27, 36, 54, 72의 순서로, 후위 순회했을 때는 12, 9, 16, 36, 72, 54, 27의 순서로 방문하게 되지요.</p>

<p><img src="http://algospot.com/media/judge-attachments/bbdb1ada72f7eb16c9291ed59d4761ff/traversal.png" alt="" /></p>

<p>어떤 이진 트리를 전위 순회했을 때 노드들의 방문 순서와, 중위 순회했을 때 노드들의 방문 순서가 주어졌다고 합시다. 이 트리를 후위 순회했을 때 각 노드들을 어떤 순서대로 방문하게 될지 계산하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤100)가 주어집니다. 각 테스트 케이스는 세 줄로 구성되며, 첫 줄에는 트리에 포함된 노드의 수 N (1≤N≤100)이 주어집니다. 그 후 두 줄에 각각 트리를 전위 순회했을 때와 중위순회 했을 때의 노드 방문 순서가 N개의 정수로 주어집니다. 각 노드는 1000 이하의 자연수로 번호 매겨져 있으며, 한 트리에서 두 노드의 번호가 같은 일은 없습니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다, 한 줄에 해당 트리의 후위 순회했을 때 노드들의 방문 순서를 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>입력으로 조어진 전위 순회 리스트와, 중위 순회 리스트를 통해 후위 순회 리스트를 찾아내야 한다. 먼저 전위 순회 리스트는 항상 루트를 우선적으로 방문하므로, 맨 앞의 요소는 해당 트리의 루트임을 알 수 있다. 이를 통해 중위 순회 리스트에서 해당 루트 성분의 위치를 찾는다면, 루트를 기준으로 왼쪽 서브트리와 오른쪽 서브트리의 크기와 구간을 알 수 있게 된다. 따라서 왼쪽 서브트리와 오른쪽 서브트리를 통해 재귀적으로 후위 순회를 출력할 수 있는 함수를 구현할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printPostOrder</span><span class="o">(</span><span class="n">List</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">List</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">preorder</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">preorder</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">inorder</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
		<span class="n">printPostOrder</span><span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span> <span class="n">inorder</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">L</span><span class="o">));</span>
		<span class="n">printPostOrder</span><span class="o">(</span><span class="n">preorder</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">),</span> <span class="n">inorder</span><span class="o">.</span><span class="na">subList</span><span class="o">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">));</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
	<span class="o">}</span>
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>[종만북]10.탐욕법-문자열 합치기</title>
	  <link>//STRJOIN</link>
	  <author></author>
	  <pubDate>2021-02-09T04:25:52+09:00</pubDate>
	  <guid>//STRJOIN</guid>
	  <description><![CDATA[
	     <h4 id="문제">문제</h4>

<p>출처 : https://www.algospot.com/judge/problem/read/STRJOIN</p>

<p>프로그래밍 언어 C 의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않는다는 것입니다. C 에서는 문자 배열로 문자열을 표현하되 \0 (NULL) 로 문자열의 끝을 지정하는데, 이래서는 문자열의 길이를 쉽게 알 수 있는 방법이 없기 때문에 여러 가지 문제가 발생하게 됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void strcat(char* dest, const char* src) {
 // dest 의 마지막 위치를 찾는다
 while(*dest) ++dest;
 // src 를 한 글자씩 dest 에 옮겨 붙인다
 while(*src) *(dest++) = *(src++);
 // 문자열의 끝을 알리는 \0 을 추가한다
 *dest = 0;
}
</code></pre></div></div>

<p>이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커진다는 것이 있습니다. 앞에 주어진 함수 strcat() 은 문자열 dest 뒤에 src 를 붙이는 함수인데, 실행 과정에서 반복문을 두 문자열의 길이를 합한 만큼 수행해야 합니다. 이 함수를 사용해 두 개의 문자열을 합치는 비용은 두 문자열의 길이의 합이라고 합시다.</p>

<p>이 함수를 이용해 n 개의 문자열을 순서와 상관없이 합쳐서 한 개의 문자열로 만들고 싶습니다. 순서가 상관 없다는 말은 {al,go,spot} 을 spotalgo 로 합치든 alspotgo 로 합치든 상관 없다는 의미입니다. 그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다. 예를 들어 먼저 al 과 go 를 합치고 (2+2=4), 이것을 spot 과 합치면 (4+4=8) 총 12 의 비용이 들지만 al 과 spot 을 합치고 (2+4=6) 이것을 다시 go 에 합치면 (6+2=8) 총 14 의 비용이 필요합니다.</p>

<p>n 개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>

<p>입력의 첫 줄에는 테스트 케이스의 수 c (c &lt;= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 문자열의 수 n (1 &lt;= n &lt;= 100) 이 주어지며, 다음 줄에는 n 개의 정수로 각 문자열의 길이가 주어집니다. 각 문자열의 길이는 1,000 이하의 자연수입니다.</p>

<h4 id="출력">출력</h4>

<p>각 테스트 케이스마다 한 줄에 모든 문자열을 합칠 때 필요한 최소 비용을 출력합니다.</p>

<h3 id="풀이">풀이</h3>

<p>각 숫자들이 입력으로 주어졌을 때, 합치는 것을 반복하는 과정에서 최소가 되는 답을 찾아야 하는데, 이 경우 어림잡아 현재 숫자목록 중 가장 작은 두 숫자끼리 더하는 것이 답이라는 것을 알 수 있다. 이를 증명하기 위해, 먼저 탐욕적 선택 속성을 증명하는데, 현재 숫자 목록에서 가장 작은 숫자와, 임의의 숫자를 더하는 것으로 가정한다. 이 때, 임의의 숫자를 그 다음으로 가장 작은 숫자로 교체한다면, 이때 더해진 숫자가 계속해서 더해지는 과정을 거칠 때 전체 합이 작아진다. 즉, 가장 작은 두 수가 더해지는 최적해가 존재하고, 최적 부분 구조 또한 남은 문자열에서 항상 최소 비용으로 합치는 것이 이득이기 때문에 성립하므로, 이 알고리즘을 통해 답을 계산할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
		<span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="n">temp</span> <span class="o">+=</span> <span class="n">p</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="n">p</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
		<span class="n">sum</span><span class="o">+=</span> <span class="n">temp</span><span class="o">;</span>
		<span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
</code></pre></div></div>

<p>구현 자체는 간단한데, 우선순위 큐를 통해 쉽게 풀 수 있다. 큐의 순서가 유지되는 우선순위큐에서 맨 앞에 있는 가장 작은 두수를 꺼내어 더하는 과정을 반복하여, 이 때 더해진 값들의 합을 출력한다.</p>

	  ]]></description>
	</item>


</channel>
</rss>
